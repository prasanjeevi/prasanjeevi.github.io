# Design Patterns

> Someone has already solved your problems

The best way to use patterns is to load your brain with them and then recognize places in your designs and existing applications where you can apply them. Instead of code reuse, with patterns you get experience reuse

The one constant in software development

No matter where you work, what you’re building, or what language you are programming in, what’s the one true constant that will be with you always?

Take the parts that vary and encapsulate them, so that later you can alter or extend the parts that vary without affecting those that don’t

Strive for loosely coupled designs between objects that interact

## OO Basics
* Abstraction
* Encapsulation
* Inheritance
* Polimorphism

## OO Principles
* Encapsulate what varies
* Favor composition over inheritance
* Program to an interface, not an implementation

## Relationships
Is-a extents -|> inheritance
Implements ..|> interface
Has-a -> extends

## Strategy Pattern
The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it

## Observer Pattern
The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically

| Pattern | Usage |
|---|---|
| Abstract Factory | 5 |
| Builder | 2 |
| Factory Method | 5 |
| Prototype | 3 |
| Singleton | 4 |
| Adapter | 4 |
| Bridge | 3 |
| Composite | 4 |
| Decorator | 3 |
| Facade | 5 |
| Flyweight | 1 |
| Proxy | 4 |
| Chain of Responsibility | 2 |
| Command | 4 |
| Interpreter | 1 |
| Iterator | 5 |
| Mediator | 2 |
| Memento | 1 |
| Observer | 5 |
| State | 3 |
| Strategy | 4 |
| Template Method | 3 |
| Visitor | 1 |
